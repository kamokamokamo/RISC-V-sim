### R.1. メモリアクセス性能
##### プログラムの実行時間 = 実行サイクル数/クロック周波数
である。よって、実行サイクル数とクロック周波数をそれぞれ求めればよい。  

クロック周波数は簡単で、想定しているハードウェアのクロック周波数を設定する機能があればよい。
 
しかし、実行サイクル数は、メモリへのアクセスを考慮するなら1命令にかかるサイクルが1であるとは限らないため、それぞれの命令が費やすサイクル数を求める機能が必要である。命令ごとの必要サイクル数の情報があるならばそれをそのまま設定すればよい。無い場合は、まず、想定しているハードウェアのメモリアクセス時間を設定して、命令ごとに、命令中にメモリアクセスを行う回数を設定する。kappyの場合、どの命令もIFで最低4回メモリアクセス。SBとLBでは追加で1回メモリアクセス。SWとLWでは追加で4回メモリアクセスである。次に「メモリアクセス時間×メモリアクセス回数+その他の時間」を計算して(n×クロックサイクル時間)から((n+1)クロックサイクル時間)の間にあるならばその命令のクロックサイクル数をn+1とすればよい。ただし、その他の時間(=他のフェイズで費やした時間)を正確に知ることは難しい。精度は落ちるが、その他の時間<<メモリアクセス時間として無視してもいいかもしれない。
##### 実装方針
・変数: execute_time, execute_cycle, clock_frequency, memory_access_timeを追加

・それぞれの命令の実行サイクル数を格納する変数を追加

・memory_access_time, 命令の種類を引数にとり、その命令の実行サイクル数を返す関数を追加

・1命令実行した直後に、execute_cycle += (その命令の実行サイクル数)とする

・すべての命令の実行が終わった後に、execute_time = execute_cycle / clock_frequencyとする

### R.2. シミュレータ精度
実行サイクル数については、R.1の実装をすればよいから、十分見積もる能力は備わっているといえる。しかし、パイプライン処理やマルチプロセッサを想定するなら、この実装ではうまく見積もれない。パイプライン処理を考慮する場合、厳密にフェイズを分割したり、パイプラインストールを実装したりと、色々な機能を追加しなければならない。マルチプロセッサを考慮する場合、どのプログラムが並列実行可能かを調べる機能が必要になる。

メモリアクセス命令数については、ロード命令、ストア命令の度に+1するカウンタを実装することで、十分な精度で見積もることができる。しかし、キャッシュを搭載している場合、メモリアクセスせずにキャッシュの参照で済むケースが生じるため、実際はシミュレーションよりもメモリアクセス命令数が少なくなる。よって、ロード命令やストア命令をキャッシュを考慮したものに書き換える必要がある。

### R.3. シミュレータの実装方法
実行時コンパイルで実装すればよい。

解釈型では、ループ処理などで同じ命令を何度も行う場合でも、命令の度に解釈されてしまうため、効率が悪い。そこで、プログラムの実行時に効率が悪くなりそうな部分をコンパイルすることで、実行速度を改善することが出来る。この方式を実行時コンパイルといい、見かけ上はインタプリタとして動作しているため、解釈型の利点(OSやCPUに依存しない状態にできる)を損なうことなく性能を上げられる。なお実際は、まず一旦中間言語(仮想マシンをターゲットとしたバイトコード)に変換してから、実行時コンパイルを行うようである(LLVMやCLRなど)。

### R.4. HDDやSSDのアクセス性能見積もり
現実的なプロセッサとの入出力性能 = 補助記憶装置へのアクセスを考慮した場合のプログラムの実行時間とする。

HDDやSSDとのプロセッサとの関係性(HDDやSSDの性能、どのような接続の仕方がされているか、どのようなアルゴリズムで入出力を行うかなど)をシミュレータに記述する必要がある。また、ロード命令やストア命令を補助記憶装置を考慮した場合に書き換える必要がある。具体的には、まず補助記憶装置へのアクセス時間を設定する変数、補助記憶装置へアクセスした回数をカウントする変数を追加する。次にロード命令時にメモリもしくはキャッシュにデータがあるかどうかを判定し、無かった場合は補助記憶装置を参照し、(補助記憶装置へアクセスした回数) += 1 する機能の追加。そして、ストア命令時に既にメモリにデータがある場合は補助記憶装置に退避し、(補助記憶装置へアクセスした回数) += 1 する機能の追加をする。後は、(補助記憶装置へのアクセス時間)×(補助記憶装置へのアクセス回数)でプログラム実行中に補助記憶装置へアクセスした時間を見積もることができる。

### R.5. 組込みシステム開発コストの見積もり
##### 総コスト = 開発費 + 原価 × 生産台数
より、

(A1-A5すべての製品の総コスト) = (ハードウェアプラットフォーム開発費) + (共通ソフトウェア開発費) + (A1-A5それぞれのハードウェア開発費の和) + (A1-A5それぞれのソフトウェア開発費の和) + (A1-A5それぞれの(原価)×(出荷台数)の和)

(A1の総コスト) = (ハードウェアプラットフォーム開発費) + (共通ソフトウェア開発費) + (A1のハードウェア開発費) + (A1のソフトウェア開発費) + (A1の原価)×(A1の出荷台数)

(A2の総コスト) = (A2のハードウェア開発費) + (A2のソフトウェア開発費) + (A2の原価)×(A2の出荷台数)

(A3の総コスト) = (A3のハードウェア開発費) + (A3のソフトウェア開発費) + (A3の原価)×(A3の出荷台数)

(A4の総コスト) = (A4のハードウェア開発費) + (A4のソフトウェア開発費) + (A4の原価)×(A4の出荷台数)

(A5の総コスト) = (A5のハードウェア開発費) + (A5のソフトウェア開発費) + (A5の原価)×(A5の出荷台数)

また、
##### 製品1個のコスト = 総コスト/生産台数 = (開発費/生産台数) + 原価
より、

(A1-A5すべての製品の1つ当たりのコスト) = (A1-A5すべての製品の総コスト) / (A1-A5それぞれの出荷台数の和)

(A1の1つ当たりのコスト) = (A1の総コスト) / (A1の出荷台数)

(A2の1つ当たりのコスト) = (A2の総コスト) / (A2の出荷台数)

(A3の1つ当たりのコスト) = (A3の総コスト) / (A3の出荷台数)

(A4の1つ当たりのコスト) = (A4の総コスト) / (A4の出荷台数)

(A5の1つ当たりのコスト) = (A5の総コスト) / (A5の出荷台数)

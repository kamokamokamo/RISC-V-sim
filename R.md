### R.1. メモリアクセス性能
##### プログラムの実行時間 = 実行サイクル数/クロック周波数
である。よって、実行サイクル数とクロック周波数をそれぞれ求めればよい。  

クロック周波数は簡単で、想定しているハードウェアのクロック周波数を設定する機能があればよい。
 
しかし、実行サイクル数は、メモリへのアクセスを考慮するなら1命令にかかるサイクルが1であるとは限らないため、それぞれの命令が費やすサイクル数を求める機能が必要である。命令ごとの必要サイクル数の情報があるならばそれをそのまま設定すればよい。無い場合は、まず、想定しているハードウェアのメモリアクセス時間を設定して、命令ごとに、命令中にメモリアクセスを行う回数を設定する。kappyの場合、どの命令もIFで最低4回メモリアクセス。SBとLBでは追加で1回メモリアクセス。SWとLWでは追加で4回メモリアクセスである。次に「メモリアクセス時間×メモリアクセス回数+その他の時間」を計算して(n×クロックサイクル時間)から((n+1)クロックサイクル時間)の間にあるならばその命令のクロックサイクル数をn+1とすればよい。ただし、その他の時間(=他のフェイズで費やした時間)を正確に知ることは難しい。精度は落ちるが、その他の時間<<メモリアクセス時間として無視してもいいかもしれない。
##### 実装方針
・変数: execute_time, execute_cycle, clock_frequency, memory_access_timeを追加

・それぞれの命令の実行サイクル数を格納する変数を追加

・memory_access_time, 命令の種類を引数にとり、その命令の実行サイクル数を返す関数を追加

・1命令実行した直後に、execute_cycle += (その命令の実行サイクル数)とする

・すべての命令の実行が終わった後に、execute_time = execute_cycle / clock_frequencyとする

### R.2. シミュレータ精度
実行サイクル数については、R.1の実装をすればよいから、十分見積もる能力は備わっているといえる。しかし、パイプライン処理を想定するなら、この実装ではうまく見積もれない。

メモリアクセス命令数については、ロード命令、ストア命令の度に+1するカウンタを実装することで、十分な精度で見積もることができる。しかし、キャッシュを搭載している場合、メモリアクセスせずにキャッシュの参照で済むケースが生じるため、実際はシミュレーションよりもメモリアクセス命令数が少なくなる。よって、ロード命令やストア命令をキャッシュを考慮したものに書き換える必要がある。

### R.3. シミュレータの実装方法
実行時コンパイルで実装すればよい。

解釈型では、ループ処理などで同じ命令を何度も行う場合でも、命令の度に解釈されてしまうため、効率が悪い。そこで、プログラムの実行時に効率が悪くなりそうな部分をコンパイルすることで、実行速度を改善することが出来る。この方式を実行時コンパイルといい、解釈型の利点(OSやCPUに依存しない状態にできる)を損なうことなく性能を上げる事ができる。LLVMなどが実行時コンパイラの例である。

### R.4. HDDやSSDのアクセス性能見積もり
現実的なプロセッサとの入出力性能 = 補助記憶装置へのアクセスを考慮した場合のプログラムの実行時間とする。

HDDやSSDとのプロセッサとの関係性(どのような接続の仕方がされているか、どのようなアルゴリズムで入出力を行うかなど)をシミュレータに記述する必要がある。また、ロード命令やストア命令を補助記憶装置を考慮した場合に書き換える必要がある。

### R.5. 組込みシステム開発コストの見積もり
##### 製品1個のコスト = 総コスト/生産台数 = (開発費/生産台数) + 原価
##### 総コスト = 開発費 + 原価 × 生産台数
